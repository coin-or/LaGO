// Copyright (C) 2006 Ivo Nowak and Stefan Vigerske
// All Rights Reserved.
// This code is published under the Common Public License.
//
// Author: Stefan Vigerske


#ifndef RELAX_H
#define RELAX_H

#include "standard.h"
#include "param.h"
#include "func.h"
#include "problem.h"
#include "opt.h"
#include "decomp.h"
#include "sampling.h"


/** Class to convexify a (decomposed) function.
    @class Convexify
    @param Relax very large
    %options double
    %default 1E+99
    Determines, when we use CGU and when we use the alpha-method to convexify a function.
    If $\lambda_{\max}\lambda_{\min} < -very\_large$, we use CGU, else we try alpha.
     If the norm of the computed alpha is > very\_large, we use also CGU.
    @param Relax CGU epsilon
    %options double $\geq0$
    %default 0.
    An epsilon, which is added to each constraint in the LP, we solve when we compute a CGU.
*/
class Convexify {
	private:
		Pointer<Param> param;

		/** Object to generate sample points. */
		Sampling sampling;
		vector<vector<dvector> > sample_set;

		Decomposition decomp;

		double very_large, cgu_eps;

		/** Diagonal of matrices, generated by alpha or cgu method.
		*/
		pair<Pointer<UserVector<double> >, Pointer<UserVector<double> > > convexify_a;
		/** Linear parts, generated by alpha or cgu method.
		*/
		pair<Pointer<UserVector<double> >, Pointer<UserVector<double> > > convexify_b;

	 	/** Indicates, whether the last function was convexified with the cgu method.
	 	*/
	 	vector<bool> convexified_by_cgu;

		/** Computes the cgu-parameters for the convexification of the k'th block of f.
		    @param f The function to convexify.
		    @param k The block number.
		*/
		void convexify_cgu(SepQcFunc& f, int k);
		/** Computes the alpha-parameters for the convexification of the k'th block of f.
		    @param f The function to convexify.
		    @param k The block number.
		    @param low Lower bounds for the k'th block.
		    @param up Upper bounds for the k'th block.
		*/
		pair<double, double> convexify_alpha(SepQcFunc& f, int k, const dvector& low, const dvector& up, Pointer<set<int> > i_quad, Pointer<set<int> > i_nonquadlin);
		pair<double, double> convexify_alpha(SepQcFunc& f, int k, const dvector& low, const dvector& up);
		pair<double, double> convexify_alpha2(SepQcFunc& f, int k, const dvector& low, const dvector& up);
	public:
		/** Constant parts, generated by alpha or cgu.
		*/
		vector<pair<double, double> > convexify_c;
		
		/** The shifting parameters which characterize the latest convexification.
		 * The function was convexified by adding sum_i shift_i (x_i-\lb x_i)(x_i-\ub x_i) for (i, shift_i) in the map.
		 */
		map<int, double> characteristica1, characteristica2;
	
		Convexify(Pointer<Param> param_)
		: param(param_), sampling(param_, "Convexify"), decomp(param)
		{ very_large=param->get_d("Relax very large", 1E+99);
			cgu_eps=param->get_d("Relax CGU epsilon", 0.);
		}
		
		/** Computes a new sample set for the nonlinear blocks of a function.
		    @param lower Lower bounds of variables.
		    @param upper Upper bounds of variables.
		    @param f The function, which block-structure we use.
		*/
		void new_sampleset(UserVector<double>& lower, UserVector<double>& upper, SepQcFunc& f);
		
		/** Computes the cgu or alpha parameters for a function.
		    @param f The function.
		    @param eq Indicates, whether also the parameters for -f should be computed.
		    @param min_eigval The minimum eigenvalues for the hessians of each block of f.
		    @param max_eigval The maximum eigenvalues for the hessians of each block of f.
		    @param convex Indicates, whether f is convex.
		    @param concave Indicates, whether f is concave.
		    @param lower Lower bounds of variables.
		    @param upper Upper bounds of variables.
		*/
		double convexify(SepQcFunc& f, bool eq, vector<double>& min_eigval, vector<double>& max_eigval, UserVector<double>& lower, UserVector<double>& upper);
		
		/** Gives a convexified function.
		    Gives the convexified function in it's decomposed form (the form, which was used in convexify).
				@param f A pair, where ew can store the convexified f and (sometimes) -f in.  At the beginning, it needs to hold the decomposed f at first place, the second needs to empty.
		*/
		void get_decomposed_functions(pair<Pointer<SepQcFunc>, Pointer<SepQcFunc> >& f);

		void check_convex2(vector<double>& min_eigval, vector<double>& max_eigval, SepQcFunc& f, const vector<vector<dvector> >& sample_set);

		/** Checks, if a problem is a convex relaxation of another problem.
		    Checks, if the minimum eigenvalues of the convexified functions are >=0.
		    Checks, if the function values of the convexified functions are lower than the value of the original functions.
		    @param conv_prob The convexified problem.
		    @param orig_prob The original problem to compare with.
		    @param test_ptr The number of sample points to use, default is 20.
		*/
		void check_convexification(MinlpProblem& conv_prob, MinlpProblem& orig_prob, const ivector& ineq_index, int test_pts=20);
};

#endif
